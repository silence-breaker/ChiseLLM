{"id": "L1-Basic_001", "level": "L1-Basic", "category": "passthrough", "instruction": "Write a Chisel module named `PassthroughBit` with a 1-bit input `in` and a 1-bit output `out`. The output should be directly connected to the input.", "input": "", "reference_code": "import chisel3._\n\nclass PassthroughBit extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(1.W))\n    val out = Output(UInt(1.W))\n  })\n  \n  io.out := io.in\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "PassthroughBit"}}
{"id": "L1-Basic_002", "level": "L1-Basic", "category": "passthrough", "instruction": "Write a Chisel module named `PassthroughByte` with a 8-bit input `in` and a 8-bit output `out`. The output should be directly connected to the input.", "input": "", "reference_code": "import chisel3._\n\nclass PassthroughByte extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  io.out := io.in\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "PassthroughByte"}}
{"id": "L1-Basic_003", "level": "L1-Basic", "category": "passthrough", "instruction": "Write a Chisel module named `PassthroughHalfWord` with a 16-bit input `in` and a 16-bit output `out`. The output should be directly connected to the input.", "input": "", "reference_code": "import chisel3._\n\nclass PassthroughHalfWord extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  io.out := io.in\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "PassthroughHalfWord"}}
{"id": "L1-Basic_004", "level": "L1-Basic", "category": "passthrough", "instruction": "Write a Chisel module named `PassthroughWord` with a 32-bit input `in` and a 32-bit output `out`. The output should be directly connected to the input.", "input": "", "reference_code": "import chisel3._\n\nclass PassthroughWord extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  io.out := io.in\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "PassthroughWord"}}
{"id": "L1-Basic_005", "level": "L1-Basic", "category": "passthrough", "instruction": "Write a Chisel module named `PassthroughDoubleWord` with a 64-bit input `in` and a 64-bit output `out`. The output should be directly connected to the input.", "input": "", "reference_code": "import chisel3._\n\nclass PassthroughDoubleWord extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(64.W))\n    val out = Output(UInt(64.W))\n  })\n  \n  io.out := io.in\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "PassthroughDoubleWord"}}
{"id": "L1-Basic_006", "level": "L1-Basic", "category": "wire_assign", "instruction": "Write a Chisel module named `WireZero` that declares a 8-bit Wire and assigns it the constant value 0. Output this wire as `out`.", "input": "", "reference_code": "import chisel3._\n\nclass WireZero extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(8.W))\n  })\n  \n  val temp = Wire(UInt(8.W))\n  temp := 0.U\n  io.out := temp\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "WireZero"}}
{"id": "L1-Basic_007", "level": "L1-Basic", "category": "wire_assign", "instruction": "Write a Chisel module named `WireMax` that declares a 8-bit Wire and assigns it the constant value 255. Output this wire as `out`.", "input": "", "reference_code": "import chisel3._\n\nclass WireMax extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(8.W))\n  })\n  \n  val temp = Wire(UInt(8.W))\n  temp := 255.U\n  io.out := temp\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "WireMax"}}
{"id": "L1-Basic_008", "level": "L1-Basic", "category": "wire_assign", "instruction": "Write a Chisel module named `WireConst` that declares a 16-bit Wire and assigns it the constant value 1234. Output this wire as `out`.", "input": "", "reference_code": "import chisel3._\n\nclass WireConst extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(16.W))\n  })\n  \n  val temp = Wire(UInt(16.W))\n  temp := 1234.U\n  io.out := temp\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "WireConst"}}
{"id": "L1-Basic_009", "level": "L1-Basic", "category": "wire_assign", "instruction": "Write a Chisel module named `WireMagic` that declares a 32-bit Wire and assigns it the constant value \"hDEADBEEF\". Output this wire as `out`.", "input": "", "reference_code": "import chisel3._\n\nclass WireMagic extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(32.W))\n  })\n  \n  val temp = Wire(UInt(32.W))\n  temp := \"hDEADBEEF\".U\n  io.out := temp\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "WireMagic"}}
{"id": "L1-Basic_010", "level": "L1-Basic", "category": "reg_init", "instruction": "Write a Chisel module named `RegZero` with a 8-bit register initialized to 0. The register value should be output as `out`.", "input": "", "reference_code": "import chisel3._\n\nclass RegZero extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(8.W))\n  })\n  \n  val reg = RegInit(0.U(8.W))\n  io.out := reg\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "RegZero"}}
{"id": "L1-Basic_011", "level": "L1-Basic", "category": "reg_init", "instruction": "Write a Chisel module named `RegHundred` with a 8-bit register initialized to 100. The register value should be output as `out`.", "input": "", "reference_code": "import chisel3._\n\nclass RegHundred extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(8.W))\n  })\n  \n  val reg = RegInit(100.U(8.W))\n  io.out := reg\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "RegHundred"}}
{"id": "L1-Basic_012", "level": "L1-Basic", "category": "reg_init", "instruction": "Write a Chisel module named `RegAllOnes` with a 16-bit register initialized to 65535. The register value should be output as `out`.", "input": "", "reference_code": "import chisel3._\n\nclass RegAllOnes extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(16.W))\n  })\n  \n  val reg = RegInit(65535.U(16.W))\n  io.out := reg\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "RegAllOnes"}}
{"id": "L2-Combinational_013", "level": "L2-Combinational", "category": "adder", "instruction": "Write a Chisel module named `Adder8bit` that takes two 8-bit unsigned inputs `a` and `b`, and outputs their sum as `sum`. The output should be 9 bits wide to avoid overflow.", "input": "", "reference_code": "import chisel3._\n\nclass Adder8bit extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(8.W))\n    val b   = Input(UInt(8.W))\n    val sum = Output(UInt(9.W))\n  })\n  \n  io.sum := io.a +& io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Adder8bit"}}
{"id": "L2-Combinational_014", "level": "L2-Combinational", "category": "adder", "instruction": "Write a Chisel module named `Adder16bit` that takes two 16-bit unsigned inputs `a` and `b`, and outputs their sum as `sum`. The output should be 17 bits wide to avoid overflow.", "input": "", "reference_code": "import chisel3._\n\nclass Adder16bit extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(16.W))\n    val b   = Input(UInt(16.W))\n    val sum = Output(UInt(17.W))\n  })\n  \n  io.sum := io.a +& io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Adder16bit"}}
{"id": "L2-Combinational_015", "level": "L2-Combinational", "category": "adder", "instruction": "Write a Chisel module named `Adder32bit` that takes two 32-bit unsigned inputs `a` and `b`, and outputs their sum as `sum`. The output should be 33 bits wide to avoid overflow.", "input": "", "reference_code": "import chisel3._\n\nclass Adder32bit extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(32.W))\n    val b   = Input(UInt(32.W))\n    val sum = Output(UInt(33.W))\n  })\n  \n  io.sum := io.a +& io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Adder32bit"}}
{"id": "L2-Combinational_016", "level": "L2-Combinational", "category": "mux2", "instruction": "Write a Chisel module named `Mux2to1_8bit` with a 1-bit select input `sel`, two 8-bit data inputs `a` and `b`, and a 8-bit output `out`. When `sel` is true, output `a`; otherwise output `b`.", "input": "", "reference_code": "import chisel3._\n\nclass Mux2to1_8bit extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(Bool())\n    val a   = Input(UInt(8.W))\n    val b   = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  io.out := Mux(io.sel, io.a, io.b)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Mux2to1_8bit"}}
{"id": "L2-Combinational_017", "level": "L2-Combinational", "category": "mux2", "instruction": "Write a Chisel module named `Mux2to1_16bit` with a 1-bit select input `sel`, two 16-bit data inputs `a` and `b`, and a 16-bit output `out`. When `sel` is true, output `a`; otherwise output `b`.", "input": "", "reference_code": "import chisel3._\n\nclass Mux2to1_16bit extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(Bool())\n    val a   = Input(UInt(16.W))\n    val b   = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  io.out := Mux(io.sel, io.a, io.b)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Mux2to1_16bit"}}
{"id": "L2-Combinational_018", "level": "L2-Combinational", "category": "mux2", "instruction": "Write a Chisel module named `Mux2to1_32bit` with a 1-bit select input `sel`, two 32-bit data inputs `a` and `b`, and a 32-bit output `out`. When `sel` is true, output `a`; otherwise output `b`.", "input": "", "reference_code": "import chisel3._\n\nclass Mux2to1_32bit extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(Bool())\n    val a   = Input(UInt(32.W))\n    val b   = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  io.out := Mux(io.sel, io.a, io.b)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Mux2to1_32bit"}}
{"id": "L2-Combinational_019", "level": "L2-Combinational", "category": "comparator", "instruction": "Write a Chisel module named `ComparatorEq8` that compares two 8-bit unsigned inputs `a` and `b`. Output a Bool `result` that is true when `a` is equal to `b`.", "input": "", "reference_code": "import chisel3._\n\nclass ComparatorEq8 extends Module {\n  val io = IO(new Bundle {\n    val a      = Input(UInt(8.W))\n    val b      = Input(UInt(8.W))\n    val result = Output(Bool())\n  })\n  \n  io.result := io.a === io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ComparatorEq8"}}
{"id": "L2-Combinational_020", "level": "L2-Combinational", "category": "comparator", "instruction": "Write a Chisel module named `ComparatorGt8` that compares two 8-bit unsigned inputs `a` and `b`. Output a Bool `result` that is true when `a` is greater than `b`.", "input": "", "reference_code": "import chisel3._\n\nclass ComparatorGt8 extends Module {\n  val io = IO(new Bundle {\n    val a      = Input(UInt(8.W))\n    val b      = Input(UInt(8.W))\n    val result = Output(Bool())\n  })\n  \n  io.result := io.a > io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ComparatorGt8"}}
{"id": "L2-Combinational_021", "level": "L2-Combinational", "category": "comparator", "instruction": "Write a Chisel module named `ComparatorLt8` that compares two 8-bit unsigned inputs `a` and `b`. Output a Bool `result` that is true when `a` is less than `b`.", "input": "", "reference_code": "import chisel3._\n\nclass ComparatorLt8 extends Module {\n  val io = IO(new Bundle {\n    val a      = Input(UInt(8.W))\n    val b      = Input(UInt(8.W))\n    val result = Output(Bool())\n  })\n  \n  io.result := io.a < io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ComparatorLt8"}}
{"id": "L2-Combinational_022", "level": "L2-Combinational", "category": "comparator", "instruction": "Write a Chisel module named `ComparatorEq16` that compares two 16-bit unsigned inputs `a` and `b`. Output a Bool `result` that is true when `a` is equal to `b`.", "input": "", "reference_code": "import chisel3._\n\nclass ComparatorEq16 extends Module {\n  val io = IO(new Bundle {\n    val a      = Input(UInt(16.W))\n    val b      = Input(UInt(16.W))\n    val result = Output(Bool())\n  })\n  \n  io.result := io.a === io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ComparatorEq16"}}
{"id": "L2-Combinational_023", "level": "L2-Combinational", "category": "bitwise", "instruction": "Write a Chisel module named `BitwiseAnd8` that performs bitwise AND on two 8-bit inputs `a` and `b`, outputting the result as `out`.", "input": "", "reference_code": "import chisel3._\n\nclass BitwiseAnd8 extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(8.W))\n    val b   = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  io.out := io.a & io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "BitwiseAnd8"}}
{"id": "L2-Combinational_024", "level": "L2-Combinational", "category": "bitwise", "instruction": "Write a Chisel module named `BitwiseOr8` that performs bitwise OR on two 8-bit inputs `a` and `b`, outputting the result as `out`.", "input": "", "reference_code": "import chisel3._\n\nclass BitwiseOr8 extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(8.W))\n    val b   = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  io.out := io.a | io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "BitwiseOr8"}}
{"id": "L2-Combinational_025", "level": "L2-Combinational", "category": "bitwise", "instruction": "Write a Chisel module named `BitwiseXor8` that performs bitwise XOR on two 8-bit inputs `a` and `b`, outputting the result as `out`.", "input": "", "reference_code": "import chisel3._\n\nclass BitwiseXor8 extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(8.W))\n    val b   = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  io.out := io.a ^ io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "BitwiseXor8"}}
{"id": "L2-Combinational_026", "level": "L2-Combinational", "category": "bitwise", "instruction": "Write a Chisel module named `BitwiseAnd16` that performs bitwise AND on two 16-bit inputs `a` and `b`, outputting the result as `out`.", "input": "", "reference_code": "import chisel3._\n\nclass BitwiseAnd16 extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(16.W))\n    val b   = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  io.out := io.a & io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "BitwiseAnd16"}}
{"id": "L3-Sequential_027", "level": "L3-Sequential", "category": "counter", "instruction": "Write a Chisel module named `Counter4bit` that implements a 4-bit counter. It should have an enable input `en`. When enabled, the counter increments each clock cycle. The current count is output as `count`.", "input": "", "reference_code": "import chisel3._\n\nclass Counter4bit extends Module {\n  val io = IO(new Bundle {\n    val en    = Input(Bool())\n    val count = Output(UInt(4.W))\n  })\n  \n  val counter = RegInit(0.U(4.W))\n  \n  when(io.en) {\n    counter := counter + 1.U\n  }\n  \n  io.count := counter\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Counter4bit"}}
{"id": "L3-Sequential_028", "level": "L3-Sequential", "category": "counter", "instruction": "Write a Chisel module named `Counter8bit` that implements a 8-bit counter. It should have an enable input `en`. When enabled, the counter increments each clock cycle. The current count is output as `count`.", "input": "", "reference_code": "import chisel3._\n\nclass Counter8bit extends Module {\n  val io = IO(new Bundle {\n    val en    = Input(Bool())\n    val count = Output(UInt(8.W))\n  })\n  \n  val counter = RegInit(0.U(8.W))\n  \n  when(io.en) {\n    counter := counter + 1.U\n  }\n  \n  io.count := counter\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Counter8bit"}}
{"id": "L3-Sequential_029", "level": "L3-Sequential", "category": "counter", "instruction": "Write a Chisel module named `CounterMod100` that implements a 8-bit counter. It should have an enable input `en`. When enabled, the counter increments each clock cycle. The current count is output as `count`.", "input": "", "reference_code": "import chisel3._\n\nclass CounterMod100 extends Module {\n  val io = IO(new Bundle {\n    val en    = Input(Bool())\n    val count = Output(UInt(8.W))\n  })\n  \n  val counter = RegInit(0.U(8.W))\n  \n  when(io.en) {\n    counter := counter + 1.U\n  }\n  \n  io.count := counter\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "CounterMod100"}}
{"id": "L3-Sequential_030", "level": "L3-Sequential", "category": "shift_register", "instruction": "Write a Chisel module named `ShiftReg4stage` that implements a 4-stage shift register with 1-bit data width. It should have an input `in` and output `out`. Each clock cycle, data shifts through the stages.", "input": "", "reference_code": "import chisel3._\n\nclass ShiftReg4stage extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(1.W))\n    val out = Output(UInt(1.W))\n  })\n  \n  val regs = Reg(Vec(4, UInt(1.W)))\n  \n  regs(0) := io.in\n  for (i <- 1 until 4) {\n    regs(i) := regs(i - 1)\n  }\n  \n  io.out := regs(4 - 1)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ShiftReg4stage"}}
{"id": "L3-Sequential_031", "level": "L3-Sequential", "category": "shift_register", "instruction": "Write a Chisel module named `ShiftReg8stage` that implements a 8-stage shift register with 1-bit data width. It should have an input `in` and output `out`. Each clock cycle, data shifts through the stages.", "input": "", "reference_code": "import chisel3._\n\nclass ShiftReg8stage extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(1.W))\n    val out = Output(UInt(1.W))\n  })\n  \n  val regs = Reg(Vec(8, UInt(1.W)))\n  \n  regs(0) := io.in\n  for (i <- 1 until 8) {\n    regs(i) := regs(i - 1)\n  }\n  \n  io.out := regs(8 - 1)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ShiftReg8stage"}}
{"id": "L3-Sequential_032", "level": "L3-Sequential", "category": "shift_register", "instruction": "Write a Chisel module named `ShiftReg4stage_8bit` that implements a 4-stage shift register with 8-bit data width. It should have an input `in` and output `out`. Each clock cycle, data shifts through the stages.", "input": "", "reference_code": "import chisel3._\n\nclass ShiftReg4stage_8bit extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  val regs = Reg(Vec(4, UInt(8.W)))\n  \n  regs(0) := io.in\n  for (i <- 1 until 4) {\n    regs(i) := regs(i - 1)\n  }\n  \n  io.out := regs(4 - 1)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ShiftReg4stage_8bit"}}
{"id": "L3-Sequential_033", "level": "L3-Sequential", "category": "edge_detector", "instruction": "Write a Chisel module named `RisingEdge` that detects a rising edge on the input signal `in`. Output `detected` should be high for one clock cycle when a rising edge is detected.", "input": "", "reference_code": "import chisel3._\n\nclass RisingEdge extends Module {\n  val io = IO(new Bundle {\n    val in       = Input(Bool())\n    val detected = Output(Bool())\n  })\n  \n  val prev = RegNext(io.in, false.B)\n  io.detected := io.in && !prev\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "RisingEdge"}}
{"id": "L3-Sequential_034", "level": "L3-Sequential", "category": "edge_detector", "instruction": "Write a Chisel module named `FallingEdge` that detects a falling edge on the input signal `in`. Output `detected` should be high for one clock cycle when a falling edge is detected.", "input": "", "reference_code": "import chisel3._\n\nclass FallingEdge extends Module {\n  val io = IO(new Bundle {\n    val in       = Input(Bool())\n    val detected = Output(Bool())\n  })\n  \n  val prev = RegNext(io.in, false.B)\n  io.detected := !io.in && prev\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "FallingEdge"}}
{"id": "L3-Sequential_035", "level": "L3-Sequential", "category": "fsm_simple", "instruction": "Write a Chisel module named `FSMOnOff` implementing a 2-state FSM with states OFF and ON. Input `toggle` transitions between states. Output `state` indicates current state (0=OFF, 1=ON).", "input": "", "reference_code": "import chisel3._\nimport chisel3.util._\n\nclass FSMOnOff extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state  = Output(Bool())\n  })\n  \n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  switch(stateReg) {\n    is(sOff) {\n      when(io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is(sOn) {\n      when(io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := (stateReg === sOn)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "FSMOnOff"}}
{"id": "L4-Advanced_036", "level": "L4-Advanced", "category": "parameterized", "instruction": "Write a parameterized Chisel module named `ParamAdder` that takes a width parameter. It should have two inputs `a` and `b` of the parameterized width, and output `sum` with width+1 bits.", "input": "", "reference_code": "import chisel3._\n\nclass ParamAdder(width: Int = 8) extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(width.W))\n    val b   = Input(UInt(width.W))\n    val sum = Output(UInt((width + 1).W))\n  })\n  \n  io.sum := io.a +& io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ParamAdder"}}
{"id": "L4-Advanced_037", "level": "L4-Advanced", "category": "valid_interface", "instruction": "Write a Chisel module named `ValidReg8bit` with a Valid interface input containing 8-bit data. When valid is asserted, store the data in a register and output it.", "input": "", "reference_code": "import chisel3._\nimport chisel3.util._\n\nclass ValidReg8bit extends Module {\n  val io = IO(new Bundle {\n    val in  = Flipped(Valid(UInt(8.W)))\n    val out = Output(UInt(8.W))\n  })\n  \n  val reg = RegInit(0.U(8.W))\n  \n  when(io.in.valid) {\n    reg := io.in.bits\n  }\n  \n  io.out := reg\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ValidReg8bit"}}
