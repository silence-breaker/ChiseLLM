{"id": "L1-Basic_001", "level": "L1-Basic", "category": "passthrough", "instruction": "I need a simple pass-through circuit. It should take a 1-bit input signal and directly forward it to the output without any modification. Name this module `PassthroughBit`.", "input": "", "reference_code": "import chisel3._\n\nclass PassthroughBit extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(1.W))\n    val out = Output(UInt(1.W))\n  })\n  \n  io.out := io.in\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "PassthroughBit"}}
{"id": "L1-Basic_002", "level": "L1-Basic", "category": "passthrough", "instruction": "I need a simple pass-through circuit. It should take a 8-bit input signal and directly forward it to the output without any modification. Name this module `PassthroughByte`.", "input": "", "reference_code": "import chisel3._\n\nclass PassthroughByte extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  io.out := io.in\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "PassthroughByte"}}
{"id": "L1-Basic_003", "level": "L1-Basic", "category": "passthrough", "instruction": "I need a simple pass-through circuit. It should take a 16-bit input signal and directly forward it to the output without any modification. Name this module `PassthroughHalfWord`.", "input": "", "reference_code": "import chisel3._\n\nclass PassthroughHalfWord extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  io.out := io.in\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "PassthroughHalfWord"}}
{"id": "L1-Basic_004", "level": "L1-Basic", "category": "passthrough", "instruction": "I need a simple pass-through circuit. It should take a 32-bit input signal and directly forward it to the output without any modification. Name this module `PassthroughWord`.", "input": "", "reference_code": "import chisel3._\n\nclass PassthroughWord extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  io.out := io.in\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "PassthroughWord"}}
{"id": "L1-Basic_005", "level": "L1-Basic", "category": "passthrough", "instruction": "I need a simple pass-through circuit. It should take a 64-bit input signal and directly forward it to the output without any modification. Name this module `PassthroughDoubleWord`.", "input": "", "reference_code": "import chisel3._\n\nclass PassthroughDoubleWord extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(64.W))\n    val out = Output(UInt(64.W))\n  })\n  \n  io.out := io.in\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "PassthroughDoubleWord"}}
{"id": "L1-Basic_006", "level": "L1-Basic", "category": "wire_assign", "instruction": "Create a Chisel module called `WireZero` that outputs a constant value. Use an internal Wire to hold the value 0, and connect it to a 8-bit output port named `out`.", "input": "", "reference_code": "import chisel3._\n\nclass WireZero extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(8.W))\n  })\n  \n  val temp = Wire(UInt(8.W))\n  temp := 0.U\n  io.out := temp\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "WireZero"}}
{"id": "L1-Basic_007", "level": "L1-Basic", "category": "wire_assign", "instruction": "Create a Chisel module called `WireMax` that outputs a constant value. Use an internal Wire to hold the value 255, and connect it to a 8-bit output port named `out`.", "input": "", "reference_code": "import chisel3._\n\nclass WireMax extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(8.W))\n  })\n  \n  val temp = Wire(UInt(8.W))\n  temp := 255.U\n  io.out := temp\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "WireMax"}}
{"id": "L1-Basic_008", "level": "L1-Basic", "category": "wire_assign", "instruction": "Create a Chisel module called `WireConst` that outputs a constant value. Use an internal Wire to hold the value 1234, and connect it to a 16-bit output port named `out`.", "input": "", "reference_code": "import chisel3._\n\nclass WireConst extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(16.W))\n  })\n  \n  val temp = Wire(UInt(16.W))\n  temp := 1234.U\n  io.out := temp\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "WireConst"}}
{"id": "L1-Basic_009", "level": "L1-Basic", "category": "wire_assign", "instruction": "Create a Chisel module called `WireMagic` that outputs a constant value. Use an internal Wire to hold the value \"hDEADBEEF\", and connect it to a 32-bit output port named `out`.", "input": "", "reference_code": "import chisel3._\n\nclass WireMagic extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(32.W))\n  })\n  \n  val temp = Wire(UInt(32.W))\n  temp := \"hDEADBEEF\".U\n  io.out := temp\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "WireMagic"}}
{"id": "L1-Basic_010", "level": "L1-Basic", "category": "reg_init", "instruction": "Implement a module `RegZero` containing a 8-bit register. The register should be initialized to 0 at reset and its value should be continuously output on a port named `out`.", "input": "", "reference_code": "import chisel3._\n\nclass RegZero extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(8.W))\n  })\n  \n  val reg = RegInit(0.U(8.W))\n  io.out := reg\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "RegZero"}}
{"id": "L1-Basic_011", "level": "L1-Basic", "category": "reg_init", "instruction": "Implement a module `RegHundred` containing a 8-bit register. The register should be initialized to 100 at reset and its value should be continuously output on a port named `out`.", "input": "", "reference_code": "import chisel3._\n\nclass RegHundred extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(8.W))\n  })\n  \n  val reg = RegInit(100.U(8.W))\n  io.out := reg\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "RegHundred"}}
{"id": "L1-Basic_012", "level": "L1-Basic", "category": "reg_init", "instruction": "Implement a module `RegAllOnes` containing a 16-bit register. The register should be initialized to 65535 at reset and its value should be continuously output on a port named `out`.", "input": "", "reference_code": "import chisel3._\n\nclass RegAllOnes extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(16.W))\n  })\n  \n  val reg = RegInit(65535.U(16.W))\n  io.out := reg\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "RegAllOnes"}}
{"id": "L2-Combinational_013", "level": "L2-Combinational", "category": "adder", "instruction": "Design an adder circuit named `Adder8bit`. It takes two 8-bit unsigned numbers as inputs (call them `a` and `b`) and produces their sum. Make the output `sum` 9 bits wide to handle potential overflow.", "input": "", "reference_code": "import chisel3._\n\nclass Adder8bit extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(8.W))\n    val b   = Input(UInt(8.W))\n    val sum = Output(UInt(9.W))\n  })\n  \n  io.sum := io.a +& io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Adder8bit"}}
{"id": "L2-Combinational_014", "level": "L2-Combinational", "category": "adder", "instruction": "Design an adder circuit named `Adder16bit`. It takes two 16-bit unsigned numbers as inputs (call them `a` and `b`) and produces their sum. Make the output `sum` 17 bits wide to handle potential overflow.", "input": "", "reference_code": "import chisel3._\n\nclass Adder16bit extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(16.W))\n    val b   = Input(UInt(16.W))\n    val sum = Output(UInt(17.W))\n  })\n  \n  io.sum := io.a +& io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Adder16bit"}}
{"id": "L2-Combinational_015", "level": "L2-Combinational", "category": "adder", "instruction": "Design an adder circuit named `Adder32bit`. It takes two 32-bit unsigned numbers as inputs (call them `a` and `b`) and produces their sum. Make the output `sum` 33 bits wide to handle potential overflow.", "input": "", "reference_code": "import chisel3._\n\nclass Adder32bit extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(32.W))\n    val b   = Input(UInt(32.W))\n    val sum = Output(UInt(33.W))\n  })\n  \n  io.sum := io.a +& io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Adder32bit"}}
{"id": "L2-Combinational_016", "level": "L2-Combinational", "category": "mux2", "instruction": "Build a 2-to-1 multiplexer module called `Mux2to1_8bit`. It should have a boolean select signal `sel`, two 8-bit data inputs `a` and `b`, and a 8-bit output `out`. When the select is true, output should be `a`; otherwise it should be `b`.", "input": "", "reference_code": "import chisel3._\n\nclass Mux2to1_8bit extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(Bool())\n    val a   = Input(UInt(8.W))\n    val b   = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  io.out := Mux(io.sel, io.a, io.b)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Mux2to1_8bit"}}
{"id": "L2-Combinational_017", "level": "L2-Combinational", "category": "mux2", "instruction": "Build a 2-to-1 multiplexer module called `Mux2to1_16bit`. It should have a boolean select signal `sel`, two 16-bit data inputs `a` and `b`, and a 16-bit output `out`. When the select is true, output should be `a`; otherwise it should be `b`.", "input": "", "reference_code": "import chisel3._\n\nclass Mux2to1_16bit extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(Bool())\n    val a   = Input(UInt(16.W))\n    val b   = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  io.out := Mux(io.sel, io.a, io.b)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Mux2to1_16bit"}}
{"id": "L2-Combinational_018", "level": "L2-Combinational", "category": "mux2", "instruction": "Build a 2-to-1 multiplexer module called `Mux2to1_32bit`. It should have a boolean select signal `sel`, two 32-bit data inputs `a` and `b`, and a 32-bit output `out`. When the select is true, output should be `a`; otherwise it should be `b`.", "input": "", "reference_code": "import chisel3._\n\nclass Mux2to1_32bit extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(Bool())\n    val a   = Input(UInt(32.W))\n    val b   = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  io.out := Mux(io.sel, io.a, io.b)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Mux2to1_32bit"}}
{"id": "L2-Combinational_019", "level": "L2-Combinational", "category": "comparator", "instruction": "I need a comparator module `ComparatorEq8` that checks if one 8-bit value is equal to another. Inputs should be named `a` and `b`, and the boolean output `result` indicates whether the comparison is true.", "input": "", "reference_code": "import chisel3._\n\nclass ComparatorEq8 extends Module {\n  val io = IO(new Bundle {\n    val a      = Input(UInt(8.W))\n    val b      = Input(UInt(8.W))\n    val result = Output(Bool())\n  })\n  \n  io.result := io.a === io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ComparatorEq8"}}
{"id": "L2-Combinational_020", "level": "L2-Combinational", "category": "comparator", "instruction": "I need a comparator module `ComparatorGt8` that checks if one 8-bit value is greater than another. Inputs should be named `a` and `b`, and the boolean output `result` indicates whether the comparison is true.", "input": "", "reference_code": "import chisel3._\n\nclass ComparatorGt8 extends Module {\n  val io = IO(new Bundle {\n    val a      = Input(UInt(8.W))\n    val b      = Input(UInt(8.W))\n    val result = Output(Bool())\n  })\n  \n  io.result := io.a > io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ComparatorGt8"}}
{"id": "L2-Combinational_021", "level": "L2-Combinational", "category": "comparator", "instruction": "I need a comparator module `ComparatorLt8` that checks if one 8-bit value is less than another. Inputs should be named `a` and `b`, and the boolean output `result` indicates whether the comparison is true.", "input": "", "reference_code": "import chisel3._\n\nclass ComparatorLt8 extends Module {\n  val io = IO(new Bundle {\n    val a      = Input(UInt(8.W))\n    val b      = Input(UInt(8.W))\n    val result = Output(Bool())\n  })\n  \n  io.result := io.a < io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ComparatorLt8"}}
{"id": "L2-Combinational_022", "level": "L2-Combinational", "category": "comparator", "instruction": "I need a comparator module `ComparatorEq16` that checks if one 16-bit value is equal to another. Inputs should be named `a` and `b`, and the boolean output `result` indicates whether the comparison is true.", "input": "", "reference_code": "import chisel3._\n\nclass ComparatorEq16 extends Module {\n  val io = IO(new Bundle {\n    val a      = Input(UInt(16.W))\n    val b      = Input(UInt(16.W))\n    val result = Output(Bool())\n  })\n  \n  io.result := io.a === io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ComparatorEq16"}}
{"id": "L2-Combinational_023", "level": "L2-Combinational", "category": "bitwise", "instruction": "Create a bitwise AND gate module named `BitwiseAnd8`. It should perform bitwise AND operation on two 8-bit inputs `a` and `b`, producing a 8-bit output `out`.", "input": "", "reference_code": "import chisel3._\n\nclass BitwiseAnd8 extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(8.W))\n    val b   = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  io.out := io.a & io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "BitwiseAnd8"}}
{"id": "L2-Combinational_024", "level": "L2-Combinational", "category": "bitwise", "instruction": "Create a bitwise OR gate module named `BitwiseOr8`. It should perform bitwise OR operation on two 8-bit inputs `a` and `b`, producing a 8-bit output `out`.", "input": "", "reference_code": "import chisel3._\n\nclass BitwiseOr8 extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(8.W))\n    val b   = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  io.out := io.a | io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "BitwiseOr8"}}
{"id": "L2-Combinational_025", "level": "L2-Combinational", "category": "bitwise", "instruction": "Create a bitwise XOR gate module named `BitwiseXor8`. It should perform bitwise XOR operation on two 8-bit inputs `a` and `b`, producing a 8-bit output `out`.", "input": "", "reference_code": "import chisel3._\n\nclass BitwiseXor8 extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(8.W))\n    val b   = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  io.out := io.a ^ io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "BitwiseXor8"}}
{"id": "L2-Combinational_026", "level": "L2-Combinational", "category": "bitwise", "instruction": "Create a bitwise AND gate module named `BitwiseAnd16`. It should perform bitwise AND operation on two 16-bit inputs `a` and `b`, producing a 16-bit output `out`.", "input": "", "reference_code": "import chisel3._\n\nclass BitwiseAnd16 extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(16.W))\n    val b   = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  io.out := io.a & io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "BitwiseAnd16"}}
{"id": "L3-Sequential_027", "level": "L3-Sequential", "category": "counter", "instruction": "Design a 4-bit up-counter module named `Counter4bit`. The counter should only increment when an enable signal `en` is high. Output the current count value on a port called `count`.", "input": "", "reference_code": "import chisel3._\n\nclass Counter4bit extends Module {\n  val io = IO(new Bundle {\n    val en    = Input(Bool())\n    val count = Output(UInt(4.W))\n  })\n  \n  val counter = RegInit(0.U(4.W))\n  \n  when(io.en) {\n    counter := counter + 1.U\n  }\n  \n  io.count := counter\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Counter4bit"}}
{"id": "L3-Sequential_028", "level": "L3-Sequential", "category": "counter", "instruction": "Design a 8-bit up-counter module named `Counter8bit`. The counter should only increment when an enable signal `en` is high. Output the current count value on a port called `count`.", "input": "", "reference_code": "import chisel3._\n\nclass Counter8bit extends Module {\n  val io = IO(new Bundle {\n    val en    = Input(Bool())\n    val count = Output(UInt(8.W))\n  })\n  \n  val counter = RegInit(0.U(8.W))\n  \n  when(io.en) {\n    counter := counter + 1.U\n  }\n  \n  io.count := counter\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "Counter8bit"}}
{"id": "L3-Sequential_029", "level": "L3-Sequential", "category": "counter", "instruction": "Design a 8-bit up-counter module named `CounterMod100`. The counter should only increment when an enable signal `en` is high. Output the current count value on a port called `count`.", "input": "", "reference_code": "import chisel3._\n\nclass CounterMod100 extends Module {\n  val io = IO(new Bundle {\n    val en    = Input(Bool())\n    val count = Output(UInt(8.W))\n  })\n  \n  val counter = RegInit(0.U(8.W))\n  \n  when(io.en) {\n    counter := counter + 1.U\n  }\n  \n  io.count := counter\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "CounterMod100"}}
{"id": "L3-Sequential_030", "level": "L3-Sequential", "category": "shift_register", "instruction": "Implement a 4-stage shift register called `ShiftReg4stage`. Each stage holds 1-bit data. Data enters through input `in` and exits through output `out` after 4 clock cycles of delay.", "input": "", "reference_code": "import chisel3._\n\nclass ShiftReg4stage extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(1.W))\n    val out = Output(UInt(1.W))\n  })\n  \n  val regs = Reg(Vec(4, UInt(1.W)))\n  \n  regs(0) := io.in\n  for (i <- 1 until 4) {\n    regs(i) := regs(i - 1)\n  }\n  \n  io.out := regs(4 - 1)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ShiftReg4stage"}}
{"id": "L3-Sequential_031", "level": "L3-Sequential", "category": "shift_register", "instruction": "Implement a 8-stage shift register called `ShiftReg8stage`. Each stage holds 1-bit data. Data enters through input `in` and exits through output `out` after 8 clock cycles of delay.", "input": "", "reference_code": "import chisel3._\n\nclass ShiftReg8stage extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(1.W))\n    val out = Output(UInt(1.W))\n  })\n  \n  val regs = Reg(Vec(8, UInt(1.W)))\n  \n  regs(0) := io.in\n  for (i <- 1 until 8) {\n    regs(i) := regs(i - 1)\n  }\n  \n  io.out := regs(8 - 1)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ShiftReg8stage"}}
{"id": "L3-Sequential_032", "level": "L3-Sequential", "category": "shift_register", "instruction": "Implement a 4-stage shift register called `ShiftReg4stage_8bit`. Each stage holds 8-bit data. Data enters through input `in` and exits through output `out` after 4 clock cycles of delay.", "input": "", "reference_code": "import chisel3._\n\nclass ShiftReg4stage_8bit extends Module {\n  val io = IO(new Bundle {\n    val in  = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  val regs = Reg(Vec(4, UInt(8.W)))\n  \n  regs(0) := io.in\n  for (i <- 1 until 4) {\n    regs(i) := regs(i - 1)\n  }\n  \n  io.out := regs(4 - 1)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ShiftReg4stage_8bit"}}
{"id": "L3-Sequential_033", "level": "L3-Sequential", "category": "edge_detector", "instruction": "Create a rising edge detector module named `RisingEdge`. It monitors an input signal `in` and outputs a one-cycle pulse on `detected` whenever the input transitions from low to high.", "input": "", "reference_code": "import chisel3._\n\nclass RisingEdge extends Module {\n  val io = IO(new Bundle {\n    val in       = Input(Bool())\n    val detected = Output(Bool())\n  })\n  \n  val prev = RegNext(io.in, false.B)\n  io.detected := io.in && !prev\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "RisingEdge"}}
{"id": "L3-Sequential_034", "level": "L3-Sequential", "category": "edge_detector", "instruction": "Create a falling edge detector module named `FallingEdge`. It monitors an input signal `in` and outputs a one-cycle pulse on `detected` whenever the input transitions from high to low.", "input": "", "reference_code": "import chisel3._\n\nclass FallingEdge extends Module {\n  val io = IO(new Bundle {\n    val in       = Input(Bool())\n    val detected = Output(Bool())\n  })\n  \n  val prev = RegNext(io.in, false.B)\n  io.detected := !io.in && prev\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "FallingEdge"}}
{"id": "L3-Sequential_035", "level": "L3-Sequential", "category": "fsm_simple", "instruction": "Implement a simple 2-state finite state machine called `FSMOnOff`. It has two states: OFF and ON. A `toggle` input causes the FSM to switch between states. The current state should be output on a boolean port `state` (false for OFF, true for ON).", "input": "", "reference_code": "import chisel3._\nimport chisel3.util._\n\nclass FSMOnOff extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state  = Output(Bool())\n  })\n  \n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  switch(stateReg) {\n    is(sOff) {\n      when(io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is(sOn) {\n      when(io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := (stateReg === sOn)\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "FSMOnOff"}}
{"id": "L4-Advanced_036", "level": "L4-Advanced", "category": "parameterized", "instruction": "I need a flexible adder that works with different bit widths. Create a parameterized Chisel module called `ParamAdder` that accepts a width parameter (use 8 as the default value). The module should add two inputs `a` and `b` of the specified width and produce a sum output that is one bit wider to prevent overflow. Important: the width parameter must have a default value so the module can be instantiated without arguments.", "input": "", "reference_code": "import chisel3._\n\nclass ParamAdder(width: Int = 8) extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(width.W))\n    val b   = Input(UInt(width.W))\n    val sum = Output(UInt((width + 1).W))\n  })\n  \n  io.sum := io.a +& io.b\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ParamAdder"}}
{"id": "L4-Advanced_037", "level": "L4-Advanced", "category": "valid_interface", "instruction": "Build a module called `ValidReg8bit` that uses Chisel's Valid interface. The module should have a Valid input carrying 8-bit data. When the valid signal is asserted, store the incoming data in a register. Output the register contents continuously on a port named `out`.", "input": "", "reference_code": "import chisel3._\nimport chisel3.util._\n\nclass ValidReg8bit extends Module {\n  val io = IO(new Bundle {\n    val in  = Flipped(Valid(UInt(8.W)))\n    val out = Output(UInt(8.W))\n  })\n  \n  val reg = RegInit(0.U(8.W))\n  \n  when(io.in.valid) {\n    reg := io.in.bits\n  }\n  \n  io.out := reg\n}\n", "test_config": {"require_compile": true, "require_elaborate": true, "require_simulate": false, "module_name": "ValidReg8bit"}}
