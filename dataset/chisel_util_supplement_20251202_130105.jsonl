{"instruction": "Build a multi-stage FSM with request and acknowledge signals.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoReqAckFSM_0 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Write an FSM that switches states when toggle is asserted.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickAlternator_1 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Write a 4-state controller using Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastProtocolCtrl_2 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Build a multi-stage FSM with request and acknowledge signals.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickHandshakeFSM_3 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Implement a flip-flop style state machine with Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleFlipper_4 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Implement a handshake protocol state machine with 4 states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickReqAckFSM_5 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Design a request-wait-ack-complete FSM using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastProtocolCtrl_6 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Build a simple protocol FSM with Enum destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartTaskFSM_7 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Create a two-state toggle FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleToggleFSM_8 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Design a simple on/off state machine using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimplePingPong_9 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Design a simple on/off state machine using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastAlternator_10 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Write a 4-state controller using Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastHandshakeFSM_11 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Design a request-wait-ack-complete FSM using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickHandshakeFSM_12 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Design a simple on/off state machine using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastAlternator_13 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Build a simple protocol FSM with Enum destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartTaskFSM_14 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Write an FSM that switches states when toggle is asserted.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickPingPong_15 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Build a toggling FSM that alternates between two states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleFlipper_16 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Implement a state machine with idle, processing, and complete states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoProcessFSM_17 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Create a 4-state request/acknowledge FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickReqAckFSM_18 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Implement a state machine with idle, processing, and complete states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoStateMgr_19 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Write a 3-state workflow FSM: idle -> busy -> done -> idle.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleStateMgr_20 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Write a 4-state controller using Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickMultiStageFSM_21 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Create a two-state toggle FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastPingPong_22 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Create a 3-state FSM (Idle, Busy, Done) using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoTaskFSM_23 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Design a request-wait-ack-complete FSM using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleProtocolCtrl_24 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Design a simple on/off state machine using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleToggleFSM_25 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Write a 3-state workflow FSM: idle -> busy -> done -> idle.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartProcessFSM_26 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Build a simple protocol FSM with Enum destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoWorkflowCtrl_27 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Create a 4-state request/acknowledge FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoProtocolCtrl_28 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Build a toggling FSM that alternates between two states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickPingPong_29 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Create a 4-state request/acknowledge FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoHandshakeFSM_30 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Create a two-state toggle FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastPingPong_31 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Write a 3-state workflow FSM: idle -> busy -> done -> idle.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleTaskFSM_32 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Build a toggling FSM that alternates between two states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickToggleFSM_33 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Create a 3-state FSM (Idle, Busy, Done) using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleStateMgr_34 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Create a two-state toggle FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoToggleFSM_35 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Implement a handshake protocol state machine with 4 states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartMultiStageFSM_36 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Write a 4-state controller using Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastProtocolCtrl_37 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Create a 4-state request/acknowledge FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoMultiStageFSM_38 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Design a request-wait-ack-complete FSM using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleMultiStageFSM_39 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Implement a handshake protocol state machine with 4 states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickProtocolCtrl_40 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Implement a handshake protocol state machine with 4 states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartMultiStageFSM_41 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Create a two-state toggle FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastToggleFSM_42 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Build a multi-stage FSM with request and acknowledge signals.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoReqAckFSM_43 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Create a two-state toggle FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleAlternator_44 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Create a 3-state FSM (Idle, Busy, Done) using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoProcessFSM_45 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Write an FSM that switches states when toggle is asserted.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastFlipper_46 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Implement a handshake protocol state machine with 4 states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickMultiStageFSM_47 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Build a simple protocol FSM with Enum destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleTaskFSM_48 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Design a simple on/off state machine using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimplePingPong_49 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Design a request-wait-ack-complete FSM using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickReqAckFSM_50 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Create a two-state toggle FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleFlipper_51 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Write a 4-state controller using Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastMultiStageFSM_53 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Build a simple protocol FSM with Enum destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartProcessFSM_56 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Implement a flip-flop style state machine with Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastAlternator_57 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Implement a handshake protocol state machine with 4 states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleReqAckFSM_58 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Write a 3-state workflow FSM: idle -> busy -> done -> idle.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartTaskFSM_59 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Build a toggling FSM that alternates between two states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartToggleFSM_60 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Implement a flip-flop style state machine with Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimplePingPong_61 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Write a 4-state controller using Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleHandshakeFSM_62 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Design a task controller FSM with three states using Enum list.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastTaskFSM_63 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Create a 4-state request/acknowledge FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartReqAckFSM_64 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Implement a state machine with idle, processing, and complete states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartTaskFSM_65 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Create a 4-state request/acknowledge FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoHandshakeFSM_66 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Design a task controller FSM with three states using Enum list.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleProcessFSM_67 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Write a 3-state workflow FSM: idle -> busy -> done -> idle.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoTaskFSM_68 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Build a multi-stage FSM with request and acknowledge signals.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartReqAckFSM_69 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Build a simple protocol FSM with Enum destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleProcessFSM_70 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Create a 4-state request/acknowledge FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoProtocolCtrl_71 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Build a multi-stage FSM with request and acknowledge signals.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastReqAckFSM_72 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Design a task controller FSM with three states using Enum list.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastProcessFSM_73 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Design a simple on/off state machine using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartPingPong_74 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Implement a state machine with idle, processing, and complete states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickWorkflowCtrl_75 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Implement a handshake protocol state machine with 4 states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickProtocolCtrl_76 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Implement a handshake protocol state machine with 4 states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastReqAckFSM_77 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Build a multi-stage FSM with request and acknowledge signals.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartMultiStageFSM_78 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Create a two-state toggle FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoPingPong_79 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Design a simple on/off state machine using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoToggleFSM_80 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Implement a flip-flop style state machine with Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickAlternator_81 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Build a toggling FSM that alternates between two states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleToggleFSM_82 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Write a 3-state workflow FSM: idle -> busy -> done -> idle.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastStateMgr_83 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Implement a state machine with idle, processing, and complete states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimpleWorkflowCtrl_84 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Design a request-wait-ack-complete FSM using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartProtocolCtrl_85 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Build a simple protocol FSM with Enum destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastProcessFSM_86 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Design a request-wait-ack-complete FSM using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastMultiStageFSM_87 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Build a simple protocol FSM with Enum destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickStateMgr_88 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Create a 3-state FSM (Idle, Busy, Done) using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickWorkflowCtrl_89 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Create a two-state toggle FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickAlternator_90 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Write a 4-state controller using Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoHandshakeFSM_91 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Write an FSM that switches states when toggle is asserted.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickPingPong_92 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Build a toggling FSM that alternates between two states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass AutoPingPong_93 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Implement a flip-flop style state machine with Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartToggleFSM_94 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Create a two-state toggle FSM using Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass FastAlternator_95 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Build a toggling FSM that alternates between two states.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SimplePingPong_96 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Write an FSM that switches states when toggle is asserted.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartAlternator_97 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Write a 4-state controller using Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickHandshakeFSM_98 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Build a simple protocol FSM with Enum destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass SmartStateMgr_99 extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val done = Input(Bool())\n    val idle = Output(Bool())\n    val busy = Output(Bool())\n    val complete = Output(Bool())\n  })\n  \n  // Define 3 states using Enum list destructuring\n  val sIdle :: sBusy :: sDone :: Nil = Enum(3)\n  val stateReg = RegInit(sIdle)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sIdle) {\n      when (io.start) {\n        stateReg := sBusy\n      }\n    }\n    is (sBusy) {\n      when (io.done) {\n        stateReg := sDone\n      }\n    }\n    is (sDone) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.idle := stateReg === sIdle\n  io.busy := stateReg === sBusy\n  io.complete := stateReg === sDone\n}"}
{"instruction": "Build a multi-stage FSM with request and acknowledge signals.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickHandshakeFSM_100 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Write a 4-state controller using Enum list destructuring.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickReqAckFSM_101 extends Module {\n  val io = IO(new Bundle {\n    val req = Input(Bool())\n    val ack = Input(Bool())\n    val state = Output(UInt(2.W))\n  })\n  \n  // Define 4 states using Enum list destructuring\n  val sIdle :: sRequest :: sWait :: sComplete :: Nil = Enum(4)\n  val stateReg = RegInit(sIdle)\n  \n  switch (stateReg) {\n    is (sIdle) {\n      when (io.req) { stateReg := sRequest }\n    }\n    is (sRequest) {\n      stateReg := sWait\n    }\n    is (sWait) {\n      when (io.ack) { stateReg := sComplete }\n    }\n    is (sComplete) {\n      stateReg := sIdle\n    }\n  }\n  \n  io.state := stateReg\n}"}
{"instruction": "Design a simple on/off state machine using chisel3.util.Enum.", "input": "", "output": "import chisel3._\nimport chisel3.util._\n\nclass QuickToggleFSM_102 extends Module {\n  val io = IO(new Bundle {\n    val toggle = Input(Bool())\n    val state = Output(Bool())\n  })\n  \n  // Define states using Enum list destructuring\n  val sOff :: sOn :: Nil = Enum(2)\n  val stateReg = RegInit(sOff)\n  \n  // State transition logic\n  switch (stateReg) {\n    is (sOff) {\n      when (io.toggle) {\n        stateReg := sOn\n      }\n    }\n    is (sOn) {\n      when (io.toggle) {\n        stateReg := sOff\n      }\n    }\n  }\n  \n  io.state := stateReg === sOn\n}"}
{"instruction": "Design a module that counts ones in a 16-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicSetBitCount_210 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val count = Output(UInt(5.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Write a Chisel module to count set bits using PopCount.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicOnesCount_211 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val count = Output(UInt(3.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Implement a population count module for 4-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass UtilOnesCount_212 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val count = Output(UInt(3.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Design a module that counts ones in a 32-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass BitOnesCount_213 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val count = Output(UInt(6.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 32-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass BitBitCounter_214 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val count = Output(UInt(6.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Implement a population count module for 32-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass BitOnesCount_215 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val count = Output(UInt(6.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Create a bit counter using PopCount for 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass BitBitCounter_216 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val count = Output(UInt(4.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Implement a population count module for 32-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicBitCounter_217 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val count = Output(UInt(6.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 4-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastBitCounter_218 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val count = Output(UInt(3.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Create a bit counter using PopCount for 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicPopCounter_219 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val count = Output(UInt(4.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicPopCounter_220 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val count = Output(UInt(4.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Implement a population count module for 4-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass UtilBitCounter_221 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val count = Output(UInt(3.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Write a Chisel module to count set bits using PopCount.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicBitCounter_222 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val count = Output(UInt(5.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Write a Chisel module to count set bits using PopCount.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass BitOnesCount_225 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val count = Output(UInt(3.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Design a module that counts ones in a 16-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass UtilSetBitCount_226 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val count = Output(UInt(5.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Create a bit counter using PopCount for 16 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass UtilSetBitCount_227 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val count = Output(UInt(5.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Create a bit counter using PopCount for 16 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastOnesCount_228 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val count = Output(UInt(5.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Design a module that counts ones in a 32-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass BitOnesCount_230 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val count = Output(UInt(6.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Implement a population count module for 4-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastPopCounter_231 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val count = Output(UInt(3.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass BitPopCounter_232 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val count = Output(UInt(4.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 16-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastOnesCount_233 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val count = Output(UInt(5.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 4-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastOnesCount_234 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val count = Output(UInt(3.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Create a bit counter using PopCount for 32 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicPopCounter_235 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val count = Output(UInt(6.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 4-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastOnesCount_236 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val count = Output(UInt(3.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Design a module that counts ones in a 8-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicSetBitCount_237 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val count = Output(UInt(4.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Write a Chisel module to count set bits using PopCount.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastBitCounter_238 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val count = Output(UInt(3.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Write a Chisel module to count set bits using PopCount.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass BitSetBitCount_239 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val count = Output(UInt(4.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Implement a population count module for 16-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastOnesCount_240 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val count = Output(UInt(5.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 16-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass UtilSetBitCount_241 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val count = Output(UInt(5.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 32-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicPopCounter_242 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val count = Output(UInt(6.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Write a Chisel module to count set bits using PopCount.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastBitCounter_243 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val count = Output(UInt(4.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Design a module that counts ones in a 32-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass UtilBitCounter_244 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val count = Output(UInt(6.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 32-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass BitOnesCount_245 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val count = Output(UInt(6.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 16-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass UtilPopCounter_246 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val count = Output(UInt(5.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Implement a population count module for 4-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastOnesCount_247 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val count = Output(UInt(3.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Implement a population count module for 16-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastPopCounter_248 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val count = Output(UInt(5.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Write a Chisel module to count set bits using PopCount.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicSetBitCount_249 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val count = Output(UInt(4.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Create a bit counter using PopCount for 32 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass BitBitCounter_250 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val count = Output(UInt(6.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Design a module that counts ones in a 4-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicPopCounter_251 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val count = Output(UInt(3.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Design a module that counts ones in a 32-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass UtilBitCounter_252 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val count = Output(UInt(6.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Write a Chisel module to count set bits using PopCount.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicBitCounter_253 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val count = Output(UInt(4.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Design a module that counts ones in a 8-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass BitOnesCount_254 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val count = Output(UInt(4.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 16-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicPopCounter_255 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val count = Output(UInt(5.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Create a bit counter using PopCount for 32 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass UtilOnesCount_256 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val count = Output(UInt(6.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Implement a population count module for 4-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicOnesCount_257 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val count = Output(UInt(3.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Implement a population count module for 16-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicBitCounter_258 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val count = Output(UInt(5.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 4-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastOnesCount_259 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val count = Output(UInt(3.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastSetBitCount_260 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val count = Output(UInt(4.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Implement a population count module for 8-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass FastOnesCount_261 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val count = Output(UInt(4.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Count the number of set bits in a 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PopCount\n\nclass LogicPopCounter_262 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val count = Output(UInt(4.W))\n  })\n  \n  // Count the number of set bits using PopCount\n  io.count := PopCount(io.in)\n}"}
{"instruction": "Implement a mirror function for 4 bits using Reverse.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass BitBitFlip_270 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Design a module that flips bit positions in a 32-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilBitReverser_271 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Create a bit reversal module for 16-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass LogicReverser_272 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Design a module that flips bit positions in a 8-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass BitBitReverser_273 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Implement a mirror function for 4 bits using Reverse.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass LogicReverser_274 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Write a bit-order reverser for 32-bit signals.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass BitMirrorBits_275 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Design a module that flips bit positions in a 16-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilReverser_276 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Design a module that flips bit positions in a 8-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilMirrorBits_277 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Reverse the bit order of a 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass LogicBitFlip_278 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Write a bit-order reverser for 4-bit signals.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilBitReverser_279 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Implement a mirror function for 4 bits using Reverse.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilBitReverser_280 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Implement a mirror function for 4 bits using Reverse.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass BitReverser_283 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Create a bit reversal module for 4-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass BitMirrorBits_284 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Write a bit-order reverser for 8-bit signals.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass BitBitFlip_285 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Reverse the bit order of a 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass LogicBitFlip_286 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Implement a mirror function for 16 bits using Reverse.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass LogicBitReverser_287 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Design a module that flips bit positions in a 32-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass BitBitReverser_288 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Create a bit reversal module for 16-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilReverser_289 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Create a bit reversal module for 8-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass FastMirrorBits_290 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Write a bit-order reverser for 8-bit signals.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass LogicBitReverser_291 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Write a bit-order reverser for 32-bit signals.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilMirrorBits_292 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Implement a mirror function for 8 bits using Reverse.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass LogicMirrorBits_293 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Implement a mirror function for 4 bits using Reverse.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilReverser_294 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Write a bit-order reverser for 8-bit signals.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass FastBitFlip_295 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Implement a mirror function for 4 bits using Reverse.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass FastBitReverser_296 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Write a bit-order reverser for 32-bit signals.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilMirrorBits_297 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Reverse the bit order of a 32-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilReverser_298 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Create a bit reversal module for 16-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilBitReverser_299 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Implement a mirror function for 4 bits using Reverse.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass LogicBitReverser_300 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Write a bit-order reverser for 4-bit signals.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass BitBitReverser_301 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Write a bit-order reverser for 4-bit signals.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilMirrorBits_302 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Implement a mirror function for 4 bits using Reverse.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilMirrorBits_303 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Reverse the bit order of a 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass LogicBitFlip_304 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Create a bit reversal module for 16-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass FastBitFlip_305 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Reverse the bit order of a 32-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilBitReverser_306 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Design a module that flips bit positions in a 4-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass BitBitReverser_307 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Create a bit reversal module for 4-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass BitBitFlip_308 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Reverse the bit order of a 32-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass FastBitReverser_309 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Design a module that flips bit positions in a 8-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass FastReverser_310 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Create a bit reversal module for 4-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass FastBitReverser_311 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Implement a mirror function for 4 bits using Reverse.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass LogicMirrorBits_312 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Design a module that flips bit positions in a 4-bit number.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilBitReverser_313 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Reverse the bit order of a 32-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass LogicBitFlip_314 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Write a bit-order reverser for 4-bit signals.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass LogicBitFlip_315 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Create a bit reversal module for 4-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilReverser_316 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Implement a mirror function for 16 bits using Reverse.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass LogicReverser_317 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Create a bit reversal module for 4-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass FastBitReverser_318 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Create a bit reversal module for 8-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass BitBitReverser_319 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Write a bit-order reverser for 8-bit signals.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass FastMirrorBits_320 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Implement a mirror function for 8 bits using Reverse.", "input": "", "output": "import chisel3._\nimport chisel3.util.Reverse\n\nclass UtilBitReverser_321 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Reverse the bit order\n  io.out := Reverse(io.in)\n}"}
{"instruction": "Design a module using Fill to replicate bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitBitFill_342 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(128.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Implement sign extension by filling 16 bits 2 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass LogicDuplicator_343 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Replicate a 16-bit input 4 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastBitFill_344 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(64.W))\n  })\n  \n  // Replicate the input 4 times\n  io.out := Fill(4, io.in)\n}"}
{"instruction": "Create a bit replicator that copies 4 bits 8 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass UtilBitExpand_345 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Create a bit replicator that copies 16 bits 8 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass LogicReplicator_346 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(128.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Create a bit replicator that copies 16 bits 4 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastBitFill_347 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(64.W))\n  })\n  \n  // Replicate the input 4 times\n  io.out := Fill(4, io.in)\n}"}
{"instruction": "Implement sign extension by filling 16 bits 2 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastBitExpand_348 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Implement sign extension by filling 4 bits 2 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitBitExpand_349 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Create a bit replicator that copies 4 bits 4 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass UtilDuplicator_350 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Replicate the input 4 times\n  io.out := Fill(4, io.in)\n}"}
{"instruction": "Implement sign extension by filling 8 bits 4 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass LogicDuplicator_351 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 4 times\n  io.out := Fill(4, io.in)\n}"}
{"instruction": "Write a bit duplicator using chisel3.util.Fill.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass UtilReplicator_352 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Design a module using Fill to replicate bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastReplicator_353 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Replicate a 8-bit input 8 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastBitFill_354 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(64.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Implement sign extension by filling 16 bits 2 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitReplicator_355 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Create a bit replicator that copies 16 bits 4 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass UtilDuplicator_356 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(64.W))\n  })\n  \n  // Replicate the input 4 times\n  io.out := Fill(4, io.in)\n}"}
{"instruction": "Write a bit duplicator using chisel3.util.Fill.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass LogicDuplicator_357 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(64.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Create a bit replicator that copies 4 bits 8 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass UtilReplicator_358 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Write a bit duplicator using chisel3.util.Fill.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastBitExpand_359 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Design a module using Fill to replicate bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass UtilBitExpand_360 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Replicate a 4-bit input 2 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass LogicBitExpand_361 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Implement sign extension by filling 4 bits 8 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass LogicBitExpand_362 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Write a bit duplicator using chisel3.util.Fill.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitBitFill_363 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(64.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Write a bit duplicator using chisel3.util.Fill.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass LogicReplicator_364 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Design a module using Fill to replicate bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitBitFill_365 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Design a module using Fill to replicate bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitDuplicator_366 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 4 times\n  io.out := Fill(4, io.in)\n}"}
{"instruction": "Replicate a 4-bit input 8 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitBitExpand_367 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Design a module using Fill to replicate bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitBitFill_368 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Design a module using Fill to replicate bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitDuplicator_369 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 4 times\n  io.out := Fill(4, io.in)\n}"}
{"instruction": "Implement sign extension by filling 8 bits 2 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastDuplicator_371 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Replicate a 8-bit input 8 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitReplicator_372 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(64.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Design a module using Fill to replicate bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass LogicReplicator_373 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Create a bit replicator that copies 8 bits 2 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitBitFill_374 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Implement sign extension by filling 4 bits 8 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastBitFill_375 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Implement sign extension by filling 4 bits 2 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass UtilBitFill_376 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Implement sign extension by filling 16 bits 4 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastBitFill_377 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(64.W))\n  })\n  \n  // Replicate the input 4 times\n  io.out := Fill(4, io.in)\n}"}
{"instruction": "Implement sign extension by filling 8 bits 2 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass UtilDuplicator_378 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Design a module using Fill to replicate bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitBitExpand_379 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(64.W))\n  })\n  \n  // Replicate the input 4 times\n  io.out := Fill(4, io.in)\n}"}
{"instruction": "Replicate a 4-bit input 2 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastReplicator_380 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Design a module using Fill to replicate bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastBitExpand_382 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(64.W))\n  })\n  \n  // Replicate the input 4 times\n  io.out := Fill(4, io.in)\n}"}
{"instruction": "Implement sign extension by filling 8 bits 8 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass UtilReplicator_383 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(64.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Implement sign extension by filling 8 bits 2 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitReplicator_384 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Replicate a 4-bit input 8 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitReplicator_386 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Create a bit replicator that copies 16 bits 8 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitReplicator_388 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(128.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Write a bit duplicator using chisel3.util.Fill.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass UtilReplicator_389 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // Replicate the input 4 times\n  io.out := Fill(4, io.in)\n}"}
{"instruction": "Design a module using Fill to replicate bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass BitDuplicator_390 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 4 times\n  io.out := Fill(4, io.in)\n}"}
{"instruction": "Design a module using Fill to replicate bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastReplicator_391 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Write a bit duplicator using chisel3.util.Fill.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastBitExpand_392 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // Replicate the input 2 times\n  io.out := Fill(2, io.in)\n}"}
{"instruction": "Write a bit duplicator using chisel3.util.Fill.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass LogicBitFill_393 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Implement sign extension by filling 8 bits 4 times.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass FastDuplicator_394 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 4 times\n  io.out := Fill(4, io.in)\n}"}
{"instruction": "Design a module using Fill to replicate bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Fill\n\nclass UtilDuplicator_395 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // Replicate the input 8 times\n  io.out := Fill(8, io.in)\n}"}
{"instruction": "Implement a log2 calculator for 16-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass UtilBitPosition_411 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Calculate the log2 of a 32-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass BitBitPosition_412 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Implement a log2 calculator for 16-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass UtilLog2Unit_413 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Implement a log2 calculator for 16-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastLog2Unit_414 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Implement a log2 calculator for 32-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastLog2Unit_415 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Create a module to compute floor(log2(x)) for 32-bit x.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastHighBitFinder_416 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Create a module to compute floor(log2(x)) for 16-bit x.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass BitBitPosition_417 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Create a module to compute floor(log2(x)) for 32-bit x.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass BitHighBitFinder_418 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Implement a log2 calculator for 8-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass LogicLog2Unit_419 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Create a module to compute floor(log2(x)) for 8-bit x.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass LogicLog2Unit_420 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Create a module to compute floor(log2(x)) for 32-bit x.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastLog2Unit_421 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Calculate the log2 of a 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass BitBitPosition_422 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass BitBitPosition_423 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Find the bit position of the highest set bit in 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastLog2Calc_424 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Create a module to compute floor(log2(x)) for 32-bit x.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass BitHighBitFinder_425 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Create a module to compute floor(log2(x)) for 16-bit x.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastLog2Calc_426 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Find the bit position of the highest set bit in 32 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastHighBitFinder_427 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass LogicBitPosition_428 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Find the bit position of the highest set bit in 32 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass BitBitPosition_429 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Calculate the log2 of a 16-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass BitHighBitFinder_430 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass UtilHighBitFinder_431 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass UtilHighBitFinder_432 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Implement a log2 calculator for 32-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastLog2Unit_433 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass UtilHighBitFinder_434 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Create a module to compute floor(log2(x)) for 32-bit x.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass LogicLog2Unit_435 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Implement a log2 calculator for 16-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass LogicLog2Calc_436 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass LogicLog2Calc_437 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Find the bit position of the highest set bit in 16 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass BitHighBitFinder_438 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Calculate the log2 of a 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass BitLog2Unit_439 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Calculate the log2 of a 16-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass UtilBitPosition_440 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Create a module to compute floor(log2(x)) for 32-bit x.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass UtilBitPosition_441 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Calculate the log2 of a 16-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass LogicHighBitFinder_442 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastLog2Calc_443 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastBitPosition_444 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Create a module to compute floor(log2(x)) for 8-bit x.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastLog2Unit_445 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastLog2Unit_446 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass UtilHighBitFinder_447 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Implement a log2 calculator for 32-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass LogicHighBitFinder_448 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass LogicLog2Calc_449 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastLog2Calc_450 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Create a module to compute floor(log2(x)) for 8-bit x.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastLog2Calc_451 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Implement a log2 calculator for 8-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass UtilHighBitFinder_452 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Implement a log2 calculator for 32-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass UtilBitPosition_453 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Find the bit position of the highest set bit in 32 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastHighBitFinder_454 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass UtilHighBitFinder_455 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Create a module to compute floor(log2(x)) for 8-bit x.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass LogicLog2Calc_456 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass LogicLog2Calc_460 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass LogicBitPosition_461 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a highest-bit finder using Log2.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass BitLog2Unit_462 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Implement a log2 calculator for 8-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.Log2\n\nclass FastLog2Unit_463 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Calculate floor(log2(in))\n  io.out := Log2(io.in)\n}"}
{"instruction": "Design a module using PriorityEncoder for 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass FastLowBitFinder_481 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Design a module using PriorityEncoder for 4 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass LogicLowBitFinder_482 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Find the position of the first set bit in 4 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass BitLowBitFinder_483 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Find the position of the first set bit in 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass LogicFirstOne_484 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Write a first-one detector using chisel3.util.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass FastFirstOne_485 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Find the position of the first set bit in 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass BitPriorityEnc_486 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Write a first-one detector using chisel3.util.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass FastPriorityEnc_487 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Design a module using PriorityEncoder for 16 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilFirstOne_488 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Find the position of the first set bit in 16 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilPriorityEnc_489 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Design a module using PriorityEncoder for 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilFirstOne_490 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Write a first-one detector using chisel3.util.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass LogicFirstOne_491 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Design a module using PriorityEncoder for 4 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilLowBitFinder_492 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Write a first-one detector using chisel3.util.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilFirstOne_493 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Create a lowest-set-bit finder for 16-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass FastPrioEncoder_494 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Design a module using PriorityEncoder for 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilPriorityEnc_495 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Design a module using PriorityEncoder for 16 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass LogicLowBitFinder_496 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Implement a priority encoder for 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass BitLowBitFinder_497 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Implement a priority encoder for 4-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass FastPriorityEnc_498 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Implement a priority encoder for 4-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass BitLowBitFinder_499 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Design a module using PriorityEncoder for 16 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass FastPrioEncoder_500 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Create a lowest-set-bit finder for 8-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass BitPriorityEnc_501 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Design a module using PriorityEncoder for 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass FastLowBitFinder_502 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Implement a priority encoder for 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass FastFirstOne_503 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Find the position of the first set bit in 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass BitPrioEncoder_504 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Implement a priority encoder for 16-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilLowBitFinder_505 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Design a module using PriorityEncoder for 4 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass LogicPrioEncoder_506 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Write a first-one detector using chisel3.util.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass LogicFirstOne_507 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Implement a priority encoder for 4-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass FastPrioEncoder_508 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Find the position of the first set bit in 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilFirstOne_509 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Write a first-one detector using chisel3.util.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilPrioEncoder_510 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Implement a priority encoder for 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass FastFirstOne_511 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Implement a priority encoder for 4-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilPrioEncoder_512 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Design a module using PriorityEncoder for 16 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass FastLowBitFinder_513 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Create a lowest-set-bit finder for 8-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass BitFirstOne_514 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Find the position of the first set bit in 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass BitPrioEncoder_515 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Find the position of the first set bit in 16 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass BitPriorityEnc_516 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Implement a priority encoder for 4-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilPriorityEnc_517 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Find the position of the first set bit in 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilPrioEncoder_518 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Create a lowest-set-bit finder for 4-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilPrioEncoder_519 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Find the position of the first set bit in 4 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass LogicFirstOne_520 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Create a lowest-set-bit finder for 4-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilPrioEncoder_521 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Implement a priority encoder for 16-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilPrioEncoder_522 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Design a module using PriorityEncoder for 16 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass LogicFirstOne_523 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Find the position of the first set bit in 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass BitFirstOne_524 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Find the position of the first set bit in 4 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilPrioEncoder_525 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Write a first-one detector using chisel3.util.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass LogicPriorityEnc_526 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val out = Output(UInt(2.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Design a module using PriorityEncoder for 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass UtilPriorityEnc_528 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Write a first-one detector using chisel3.util.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass LogicPrioEncoder_529 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(3.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Write a first-one detector using chisel3.util.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass FastPriorityEnc_530 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Create a lowest-set-bit finder for 16-bit values.", "input": "", "output": "import chisel3._\nimport chisel3.util.PriorityEncoder\n\nclass FastPrioEncoder_531 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  // Find position of least significant set bit\n  io.out := PriorityEncoder(io.in)\n}"}
{"instruction": "Convert a 4-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOneHotDec_551 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Convert a 8-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOHConverter_552 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Write a one-hot to binary converter for 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOHDecoder_553 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Implement one-hot to binary decoder for 8 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOHDecoder_554 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Convert a 4-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOneHotToBin_555 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Convert a 4-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOneHotToBin_556 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Implement one-hot to binary decoder for 4 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass LogicOneHotDec_557 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Create a one-hot decoder using OHToUInt.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOHDecoder_558 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Convert a 8-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOneHotToBin_559 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Design a module that converts one-hot encoding to unsigned.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOHConverter_560 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Design a module that converts one-hot encoding to unsigned.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass BitOneHotToBin_561 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Implement one-hot to binary decoder for 16 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass BitOHDecoder_562 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Write a one-hot to binary converter for 16-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOneHotDec_563 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Design a module that converts one-hot encoding to unsigned.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass LogicOHDecoder_564 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Design a module that converts one-hot encoding to unsigned.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass LogicOHConverter_565 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Create a one-hot decoder using OHToUInt.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOHDecoder_566 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Write a one-hot to binary converter for 4-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOneHotDec_567 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Write a one-hot to binary converter for 4-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOneHotToBin_568 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Design a module that converts one-hot encoding to unsigned.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOHDecoder_569 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Design a module that converts one-hot encoding to unsigned.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOneHotDec_570 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Design a module that converts one-hot encoding to unsigned.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOHConverter_571 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Write a one-hot to binary converter for 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass LogicOneHotDec_572 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Create a one-hot decoder using OHToUInt.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOHConverter_573 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Convert a 8-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass BitOHConverter_574 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Convert a 4-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass LogicOHConverter_575 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Write a one-hot to binary converter for 4-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass LogicOHConverter_576 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Design a module that converts one-hot encoding to unsigned.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOneHotDec_577 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Write a one-hot to binary converter for 16-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOHConverter_578 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Implement one-hot to binary decoder for 4 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOHConverter_579 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Design a module that converts one-hot encoding to unsigned.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOHConverter_580 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Write a one-hot to binary converter for 16-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass LogicOHDecoder_581 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Design a module that converts one-hot encoding to unsigned.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass LogicOHDecoder_582 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Create a one-hot decoder using OHToUInt.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass BitOneHotDec_584 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Create a one-hot decoder using OHToUInt.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOHConverter_585 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Convert a 8-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOHConverter_586 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Convert a 16-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass LogicOHConverter_587 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Implement one-hot to binary decoder for 16 bits.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOneHotDec_588 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Write a one-hot to binary converter for 16-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass LogicOneHotDec_589 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Create a one-hot decoder using OHToUInt.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOHDecoder_590 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Create a one-hot decoder using OHToUInt.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOneHotToBin_591 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Convert a 8-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass BitOneHotToBin_592 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Convert a 8-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOHConverter_593 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Convert a 16-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOHDecoder_594 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Convert a 16-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOneHotDec_595 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Create a one-hot decoder using OHToUInt.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass BitOHDecoder_596 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Write a one-hot to binary converter for 4-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOneHotToBin_597 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Convert a 4-bit one-hot code to binary.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOneHotToBin_598 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Design a module that converts one-hot encoding to unsigned.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass FastOHDecoder_599 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(16.W))\n    val binary = Output(UInt(4.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Write a one-hot to binary converter for 8-bit input.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass BitOHDecoder_600 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(8.W))\n    val binary = Output(UInt(3.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Design a module that converts one-hot encoding to unsigned.", "input": "", "output": "import chisel3._\nimport chisel3.util.OHToUInt\n\nclass UtilOHDecoder_601 extends Module {\n  val io = IO(new Bundle {\n    val oneHot = Input(UInt(4.W))\n    val binary = Output(UInt(2.W))\n  })\n  \n  // Convert one-hot encoding to binary\n  io.binary := OHToUInt(io.oneHot)\n}"}
{"instruction": "Create a one-hot encoder using UIntToOH.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass FastOHEncoder_621 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilOHEncoder_622 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(4.W))\n    val oneHot = Output(UInt(16.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Convert a binary number to 16-bit one-hot encoding.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass FastOHEncoder_623 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(4.W))\n    val oneHot = Output(UInt(16.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Write a binary to one-hot converter.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass FastOHEncoder_624 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Convert a binary number to 4-bit one-hot encoding.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicBinToOneHot_625 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilOHGenerator_626 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Write a binary to one-hot converter.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicOHGenerator_627 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Convert a binary number to 8-bit one-hot encoding.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicOHEncoder_630 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Write a binary to one-hot converter.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass BitOHEncoder_631 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilOneHotEnc_632 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(4.W))\n    val oneHot = Output(UInt(16.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Design a module that produces 4-bit one-hot output.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilOneHotEnc_633 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Design a module that produces 16-bit one-hot output.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass FastBinToOneHot_634 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(4.W))\n    val oneHot = Output(UInt(16.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Convert a binary number to 4-bit one-hot encoding.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilOHGenerator_635 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Design a module that produces 4-bit one-hot output.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicOneHotEnc_636 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Convert a binary number to 16-bit one-hot encoding.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicOneHotEnc_637 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(4.W))\n    val oneHot = Output(UInt(16.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Convert a binary number to 8-bit one-hot encoding.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicOHGenerator_638 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Convert a binary number to 8-bit one-hot encoding.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass BitOHGenerator_639 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Create a one-hot encoder using UIntToOH.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass BitBinToOneHot_640 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Convert a binary number to 16-bit one-hot encoding.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass FastOneHotEnc_641 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(4.W))\n    val oneHot = Output(UInt(16.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass FastOHEncoder_645 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Convert a binary number to 8-bit one-hot encoding.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilOneHotEnc_647 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass BitOneHotEnc_648 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Design a module that produces 8-bit one-hot output.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass FastOHEncoder_649 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Design a module that produces 4-bit one-hot output.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicOneHotEnc_650 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Convert a binary number to 4-bit one-hot encoding.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilOneHotEnc_651 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Design a module that produces 16-bit one-hot output.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicOneHotEnc_652 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(4.W))\n    val oneHot = Output(UInt(16.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Create a one-hot encoder using UIntToOH.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilBinToOneHot_653 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass BitOHEncoder_654 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicBinToOneHot_655 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(4.W))\n    val oneHot = Output(UInt(16.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilOneHotEnc_656 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Design a module that produces 16-bit one-hot output.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass BitOneHotEnc_657 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(4.W))\n    val oneHot = Output(UInt(16.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass FastOneHotEnc_658 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Write a binary to one-hot converter.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilBinToOneHot_659 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass FastBinToOneHot_660 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Create a one-hot encoder using UIntToOH.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilOHGenerator_661 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Convert a binary number to 8-bit one-hot encoding.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass FastOneHotEnc_662 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Create a one-hot encoder using UIntToOH.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilBinToOneHot_663 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass FastOneHotEnc_664 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Write a binary to one-hot converter.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicBinToOneHot_665 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicBinToOneHot_666 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(4.W))\n    val oneHot = Output(UInt(16.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Design a module that produces 8-bit one-hot output.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass FastOHEncoder_667 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Design a module that produces 16-bit one-hot output.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass BitOneHotEnc_668 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(4.W))\n    val oneHot = Output(UInt(16.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Write a binary to one-hot converter.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicOHGenerator_669 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Design a module that produces 8-bit one-hot output.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilBinToOneHot_670 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicOHEncoder_671 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass BitOHGenerator_672 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(4.W))\n    val oneHot = Output(UInt(16.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Design a module that produces 4-bit one-hot output.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass FastBinToOneHot_673 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Implement binary to one-hot encoder.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilOHEncoder_674 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(2.W))\n    val oneHot = Output(UInt(4.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Create a one-hot encoder using UIntToOH.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass LogicOHEncoder_675 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(3.W))\n    val oneHot = Output(UInt(8.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Design a module that produces 16-bit one-hot output.", "input": "", "output": "import chisel3._\nimport chisel3.util.UIntToOH\n\nclass UtilOHEncoder_676 extends Module {\n  val io = IO(new Bundle {\n    val binary = Input(UInt(4.W))\n    val oneHot = Output(UInt(16.W))\n  })\n  \n  // Convert binary to one-hot encoding\n  io.oneHot := UIntToOH(io.binary)\n}"}
{"instruction": "Write a selector using chisel3.util.Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass LogicOneHotMux_690 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Write a selector using chisel3.util.Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass LogicOHSelector_691 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Implement a 4-way one-hot selector using Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastMux1H_692 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(16.W))\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val in3 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Design a one-hot MUX for 32-bit data.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass BitMux1H_693 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Write a selector using chisel3.util.Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass UtilMux1H_694 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Write a selector using chisel3.util.Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass LogicOHSelector_695 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Write a selector using chisel3.util.Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass BitOneHotMux_696 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Create a one-hot multiplexer for 32-bit inputs.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass LogicOHSelector_697 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Implement a 4-way one-hot selector using Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass UtilOneHotMux_698 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(16.W))\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val in3 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Build a one-hot encoded multiplexer.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass LogicOneHotMux_699 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(16.W))\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val in3 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Write a selector using chisel3.util.Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass UtilOHSelector_700 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Design a one-hot MUX for 16-bit data.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastOHSelector_701 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(16.W))\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val in3 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Create a one-hot multiplexer for 8-bit inputs.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass BitOneHotMux_702 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Implement a 4-way one-hot selector using Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass LogicOneHotMux_703 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Create a one-hot multiplexer for 8-bit inputs.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastOneHotSwitch_704 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Implement a 4-way one-hot selector using Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastOneHotMux_705 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Implement a 4-way one-hot selector using Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass BitOneHotMux_706 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(16.W))\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val in3 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Create a one-hot multiplexer for 16-bit inputs.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass BitOneHotSwitch_707 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(16.W))\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val in3 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Implement a 4-way one-hot selector using Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastOneHotSwitch_708 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Design a one-hot MUX for 8-bit data.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastOneHotSwitch_709 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Design a one-hot MUX for 8-bit data.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass BitOHSelector_710 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Implement a 4-way one-hot selector using Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass BitMux1H_711 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Build a one-hot encoded multiplexer.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass LogicOneHotMux_712 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Build a one-hot encoded multiplexer.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass UtilOneHotMux_713 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Build a one-hot encoded multiplexer.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass BitOneHotMux_714 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Implement a 4-way one-hot selector using Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastOneHotSwitch_715 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(16.W))\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val in3 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Write a selector using chisel3.util.Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass BitOHSelector_716 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(16.W))\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val in3 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Create a one-hot multiplexer for 8-bit inputs.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastMux1H_717 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Write a selector using chisel3.util.Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass LogicOneHotSwitch_718 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Build a one-hot encoded multiplexer.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass UtilOneHotMux_719 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Write a selector using chisel3.util.Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastOneHotMux_720 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Build a one-hot encoded multiplexer.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass LogicOneHotMux_721 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Write a selector using chisel3.util.Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastMux1H_722 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Implement a 4-way one-hot selector using Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass BitOHSelector_723 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Build a one-hot encoded multiplexer.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastMux1H_724 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Design a one-hot MUX for 32-bit data.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass UtilMux1H_725 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Write a selector using chisel3.util.Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastOneHotSwitch_726 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Create a one-hot multiplexer for 32-bit inputs.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass UtilOneHotSwitch_727 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Design a one-hot MUX for 32-bit data.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass LogicOneHotSwitch_728 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Design a one-hot MUX for 16-bit data.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass LogicOneHotMux_729 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(16.W))\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val in3 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Create a one-hot multiplexer for 32-bit inputs.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass UtilMux1H_730 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Create a one-hot multiplexer for 8-bit inputs.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastMux1H_731 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Write a selector using chisel3.util.Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastOHSelector_732 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Implement a 4-way one-hot selector using Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass UtilOneHotSwitch_733 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Implement a 4-way one-hot selector using Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass BitOneHotSwitch_734 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(16.W))\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val in3 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Design a one-hot MUX for 8-bit data.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastMux1H_735 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Build a one-hot encoded multiplexer.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass LogicOHSelector_737 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Write a selector using chisel3.util.Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass FastOHSelector_738 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Implement a 4-way one-hot selector using Mux1H.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass BitMux1H_739 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(8.W))\n    val in1 = Input(UInt(8.W))\n    val in2 = Input(UInt(8.W))\n    val in3 = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Create a one-hot multiplexer for 32-bit inputs.", "input": "", "output": "import chisel3._\nimport chisel3.util.Mux1H\n\nclass BitMux1H_740 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(UInt(4.W))\n    val in0 = Input(UInt(32.W))\n    val in1 = Input(UInt(32.W))\n    val in2 = Input(UInt(32.W))\n    val in3 = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  \n  // One-hot multiplexer\n  io.out := Mux1H(Seq(\n    io.sel(0) -> io.in0,\n    io.sel(1) -> io.in1,\n    io.sel(2) -> io.in2,\n    io.sel(3) -> io.in3\n  ))\n}"}
{"instruction": "Implement a 16-bit shift register using Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastConcatReg_500 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(16.W))\n  })\n  \n  val shiftReg = RegInit(0.U(16.W))\n  shiftReg := Cat(shiftReg(14, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Design a 8-stage serial-in parallel-out register using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass CycleBitShifter_501 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Implement a 16-bit shift register using Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncShiftPipe_502 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(16.W))\n  })\n  \n  val shiftReg = RegInit(0.U(16.W))\n  shiftReg := Cat(shiftReg(14, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Design a 16-stage serial-in parallel-out register using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncConcatReg_503 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(16.W))\n  })\n  \n  val shiftReg = RegInit(0.U(16.W))\n  shiftReg := Cat(shiftReg(14, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastConcatReg_504 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass CycleConcatReg_505 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Write a shift register that uses Cat to shift data left.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastConcatReg_506 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass DataShiftPipe_507 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Design a 16-stage serial-in parallel-out register using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncBitShifter_508 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(16.W))\n  })\n  \n  val shiftReg = RegInit(0.U(16.W))\n  shiftReg := Cat(shiftReg(14, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Implement a 8-bit shift register using Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncShiftPipe_509 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Write a shift register that uses Cat to shift data left.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncBitShifter_510 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Implement a 8-bit shift register using Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncCatShift_511 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass CycleCatShift_512 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Write a shift register that uses Cat to shift data left.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncShiftPipe_513 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(16.W))\n  })\n  \n  val shiftReg = RegInit(0.U(16.W))\n  shiftReg := Cat(shiftReg(14, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Design a 4-stage serial-in parallel-out register using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass CycleCatShift_514 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Design a 4-stage serial-in parallel-out register using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncCatShift_515 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Write a shift register that uses Cat to shift data left.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass CycleConcatReg_516 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass DataConcatReg_517 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(16.W))\n  })\n  \n  val shiftReg = RegInit(0.U(16.W))\n  shiftReg := Cat(shiftReg(14, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass DataConcatReg_518 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass DataCatShift_519 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastShiftPipe_520 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Create a shift register that shifts in one bit at a time using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncShiftPipe_521 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(16.W))\n  })\n  \n  val shiftReg = RegInit(0.U(16.W))\n  shiftReg := Cat(shiftReg(14, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Write a shift register that uses Cat to shift data left.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastShiftPipe_522 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Design a 8-stage serial-in parallel-out register using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass CycleBitShifter_523 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass DataBitShifter_524 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Design a 8-stage serial-in parallel-out register using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncShiftPipe_525 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Design a 4-stage serial-in parallel-out register using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncConcatReg_526 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Implement a 4-bit shift register using Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass CycleConcatReg_527 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Create a shift register that shifts in one bit at a time using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastShiftPipe_528 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Design a 4-stage serial-in parallel-out register using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass DataBitShifter_529 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Implement a 8-bit shift register using Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass CycleBitShifter_530 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastConcatReg_531 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Implement a 16-bit shift register using Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastCatShift_532 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(16.W))\n  })\n  \n  val shiftReg = RegInit(0.U(16.W))\n  shiftReg := Cat(shiftReg(14, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Create a shift register that shifts in one bit at a time using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncBitShifter_533 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass DataConcatReg_534 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncShiftPipe_535 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Write a shift register that uses Cat to shift data left.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastCatShift_536 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(16.W))\n  })\n  \n  val shiftReg = RegInit(0.U(16.W))\n  shiftReg := Cat(shiftReg(14, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncBitShifter_537 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(16.W))\n  })\n  \n  val shiftReg = RegInit(0.U(16.W))\n  shiftReg := Cat(shiftReg(14, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Implement a 8-bit shift register using Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastBitShifter_538 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass DataConcatReg_539 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Implement a 8-bit shift register using Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastShiftPipe_540 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncCatShift_541 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(16.W))\n  })\n  \n  val shiftReg = RegInit(0.U(16.W))\n  shiftReg := Cat(shiftReg(14, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Create a shift register that shifts in one bit at a time using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass CycleBitShifter_542 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Design a 8-stage serial-in parallel-out register using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastConcatReg_543 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Design a 16-stage serial-in parallel-out register using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass CycleShiftPipe_544 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(16.W))\n  })\n  \n  val shiftReg = RegInit(0.U(16.W))\n  shiftReg := Cat(shiftReg(14, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Design a 8-stage serial-in parallel-out register using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastConcatReg_545 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Design a 4-stage serial-in parallel-out register using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass FastShiftPipe_546 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  \n  val shiftReg = RegInit(0.U(4.W))\n  shiftReg := Cat(shiftReg(2, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Build a bit shifter using chisel3.util.Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass DataBitShifter_547 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Create a shift register that shifts in one bit at a time using Cat.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncCatShift_548 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
{"instruction": "Implement a 8-bit shift register using Cat for concatenation.", "input": "", "output": "import chisel3._\nimport chisel3.util.Cat\n\nclass SyncCatShift_549 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(UInt(8.W))\n  })\n  \n  val shiftReg = RegInit(0.U(8.W))\n  shiftReg := Cat(shiftReg(6, 0), io.in)\n  io.out := shiftReg\n}"}
