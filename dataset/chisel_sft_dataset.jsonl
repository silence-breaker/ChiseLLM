{"instruction": "Use 'when' to assign output based on a condition.", "input": "", "output": "\nimport chisel3._\n\nclass StatusLogic_3 extends Module {\n  val io = IO(new Bundle {\n    val cond = Input(Bool())\n    val a = Input(UInt(15.W))\n    val out = Output(UInt(15.W))\n  })\n  \n  io.out := 0.U\n  \n  when (io.cond) {\n    io.out := io.a\n  } .otherwise {\n    io.out := 0.U\n  }\n}"}
{"instruction": "Use 'when' to assign output based on a condition.", "input": "", "output": "\nimport chisel3._\n\nclass CondLogic_0 extends Module {\n  val io = IO(new Bundle {\n    val cond = Input(Bool())\n    val a = Input(UInt(24.W))\n    val out = Output(UInt(24.W))\n  })\n  \n  io.out := 0.U\n  \n  when (io.cond) {\n    io.out := io.a\n  } .otherwise {\n    io.out := 0.U\n  }\n}"}
{"instruction": "Use 'when' to assign output based on a condition.", "input": "", "output": "\nimport chisel3._\n\nclass StatusFlow_1 extends Module {\n  val io = IO(new Bundle {\n    val cond = Input(Bool())\n    val a = Input(UInt(4.W))\n    val out = Output(UInt(4.W))\n  })\n  \n  io.out := 0.U\n  \n  when (io.cond) {\n    io.out := io.a\n  } .otherwise {\n    io.out := 0.U\n  }\n}"}
{"instruction": "Define a 20-bit SInt Wire named 'v_666'.", "input": "", "output": "\nimport chisel3._\n\nclass BasicWire_4 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(SInt(20.W))\n  })\n  // Task: Define a SInt Wire named 'v_666'\n  val v_666 = Wire(SInt(20.W))\n  \n  \n  v_666 := 0.U.asTypeOf(v_666)\n  \n\n  io.out := v_666\n}"}
{"instruction": "Define a Bundle with a 17-bit UInt and a Bool, then instantiate it.", "input": "", "output": "\nimport chisel3._\n\nclass MyBundle_5 extends Bundle {\n  val field1 = UInt(17.W)\n  val field2 = Bool()\n}\n\nclass LocalInterface_5 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(new MyBundle_5)\n  })\n  \n  val blob_966 = Wire(new MyBundle_5)\n  blob_966.field1 := 123.U\n  blob_966.field2 := true.B\n  \n  io.out := blob_966\n}"}
{"instruction": "Implement a module performing addition on two 17-bit inputs.", "input": "", "output": "\nimport chisel3._\n\nclass SimpleAdder_6 extends Module {\n  val io = IO(new Bundle {\n    val a = Input(UInt(17.W))\n    val b = Input(UInt(17.W))\n    val out = Output(UInt(17.W))\n  })\n  \n  // Logic: addition\n  io.out := io.a + io.b\n}"}
{"instruction": "Define a Bundle with a 28-bit UInt and a Bool, then instantiate it.", "input": "", "output": "\nimport chisel3._\n\nclass MyBundle_7 extends Bundle {\n  val field1 = UInt(28.W)\n  val field2 = Bool()\n}\n\nclass TestStruct_7 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(new MyBundle_7)\n  })\n  \n  val blob_975 = Wire(new MyBundle_7)\n  blob_975.field1 := 123.U\n  blob_975.field2 := true.B\n  \n  io.out := blob_975\n}"}
{"instruction": "Define a Wire Vec of 2 UInts, each 10-bit wide.", "input": "", "output": "\nimport chisel3._\n\nclass LocalVec_8 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(Vec(2, UInt(10.W)))\n  })\n  // Task: Define a Vec of 2 UInts\n  val vec_368 = Wire(Vec(2, UInt(10.W)))\n  \n  for (i <- 0 until 2) {\n    vec_368(i) := 0.U.asTypeOf(UInt(10.W))\n  }\n\n  io.out := vec_368\n}"}
{"instruction": "Define a Wire Vec of 4 UInts, each 18-bit wide.", "input": "", "output": "\nimport chisel3._\n\nclass TestBuffer_10 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(Vec(4, UInt(18.W)))\n  })\n  // Task: Define a Vec of 4 UInts\n  val vec_467 = Wire(Vec(4, UInt(18.W)))\n  \n  for (i <- 0 until 4) {\n    vec_467(i) := 0.U.asTypeOf(UInt(18.W))\n  }\n\n  io.out := vec_467\n}"}
{"instruction": "Define a Bundle with a 18-bit UInt and a Bool, then instantiate it.", "input": "", "output": "\nimport chisel3._\n\nclass MyBundle_11 extends Bundle {\n  val field1 = UInt(18.W)\n  val field2 = Bool()\n}\n\nclass BasicInterface_11 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(new MyBundle_11)\n  })\n  \n  val blob_105 = Wire(new MyBundle_11)\n  blob_105.field1 := 123.U\n  blob_105.field2 := true.B\n  \n  io.out := blob_105\n}"}
{"instruction": "Define a Bundle with a 18-bit UInt and a Bool, then instantiate it.", "input": "", "output": "\nimport chisel3._\n\nclass MyBundle_13 extends Bundle {\n  val field1 = UInt(18.W)\n  val field2 = Bool()\n}\n\nclass SimpleInterface_13 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(new MyBundle_13)\n  })\n  \n  val blob_784 = Wire(new MyBundle_13)\n  blob_784.field1 := 123.U\n  blob_784.field2 := true.B\n  \n  io.out := blob_784\n}"}
{"instruction": "Implement a 7-bit counter with enable signal.", "input": "", "output": "\nimport chisel3._\n\nclass DataCounter_14 extends Module {\n  val io = IO(new Bundle {\n    val en = Input(Bool())\n    val out = Output(UInt(7.W))\n  })\n  \n  val cnt = RegInit(0.U(7.W))\n  \n  when (io.en) {\n    cnt := cnt + 1.U\n  }\n  \n  io.out := cnt\n}"}
{"instruction": "Implement a 2-to-1 Multiplexer for 23-bit signals.", "input": "", "output": "\nimport chisel3._\n\nclass SignalSelector_15 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(Bool())\n    val a = Input(UInt(23.W))\n    val b = Input(UInt(23.W))\n    val out = Output(UInt(23.W))\n  })\n  \n  // Logic: 2-to-1 Mux\n  io.out := Mux(io.sel, io.a, io.b)\n}"}
{"instruction": "Implement a 2-to-1 Multiplexer for 15-bit signals.", "input": "", "output": "\nimport chisel3._\n\nclass SignalChooser_17 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(Bool())\n    val a = Input(UInt(15.W))\n    val b = Input(UInt(15.W))\n    val out = Output(UInt(15.W))\n  })\n  \n  // Logic: 2-to-1 Mux\n  io.out := Mux(io.sel, io.a, io.b)\n}"}
{"instruction": "Implement a 2-to-1 Multiplexer for 31-bit signals.", "input": "", "output": "\nimport chisel3._\n\nclass DataSwitch_19 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(Bool())\n    val a = Input(UInt(31.W))\n    val b = Input(UInt(31.W))\n    val out = Output(UInt(31.W))\n  })\n  \n  // Logic: 2-to-1 Mux\n  io.out := Mux(io.sel, io.a, io.b)\n}"}
{"instruction": "Define a 25-bit UInt Reg named 'v_741'.", "input": "", "output": "\nimport chisel3._\n\nclass TestUIntReg_20 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(25.W))\n  })\n  // Task: Define a UInt Reg named 'v_741'\n  val v_741 = Reg(UInt(25.W))\n  \n  \n  v_741 := 0.U.asTypeOf(v_741)\n  \n\n  io.out := v_741\n}"}
{"instruction": "Implement a 2-stage shift register.", "input": "", "output": "\nimport chisel3._\n\nclass PulseShiftReg_21 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(11.W))\n    val out = Output(UInt(11.W))\n  })\n  \n  val r1 = RegNext(io.in)\n  val r2 = RegNext(r1)\n  \n  io.out := r2\n}"}
{"instruction": "Implement a 2-to-1 Multiplexer for 21-bit signals.", "input": "", "output": "\nimport chisel3._\n\nclass SignalMux_22 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(Bool())\n    val a = Input(UInt(21.W))\n    val b = Input(UInt(21.W))\n    val out = Output(UInt(21.W))\n  })\n  \n  // Logic: 2-to-1 Mux\n  io.out := Mux(io.sel, io.a, io.b)\n}"}
{"instruction": "Implement a module performing bitwise OR on two 12-bit inputs.", "input": "", "output": "\nimport chisel3._\n\nclass FastMerge_23 extends Module {\n  val io = IO(new Bundle {\n    val a = Input(UInt(12.W))\n    val b = Input(UInt(12.W))\n    val out = Output(UInt(12.W))\n  })\n  \n  // Logic: bitwise OR\n  io.out := io.a | io.b\n}"}
{"instruction": "Define a Bundle with a 31-bit UInt and a Bool, then instantiate it.", "input": "", "output": "\nimport chisel3._\n\nclass MyBundle_24 extends Bundle {\n  val field1 = UInt(31.W)\n  val field2 = Bool()\n}\n\nclass GlobalStruct_24 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(new MyBundle_24)\n  })\n  \n  val blob_932 = Wire(new MyBundle_24)\n  blob_932.field1 := 123.U\n  blob_932.field2 := true.B\n  \n  io.out := blob_932\n}"}
{"instruction": "Define a Wire Vec of 4 UInts, each 8-bit wide.", "input": "", "output": "\nimport chisel3._\n\nclass GlobalBus_25 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(Vec(4, UInt(8.W)))\n  })\n  // Task: Define a Vec of 4 UInts\n  val vec_878 = Wire(Vec(4, UInt(8.W)))\n  \n  for (i <- 0 until 4) {\n    vec_878(i) := 0.U.asTypeOf(UInt(8.W))\n  }\n\n  io.out := vec_878\n}"}
{"instruction": "Use 'when' to assign output based on a condition.", "input": "", "output": "\nimport chisel3._\n\nclass StatusFlow_26 extends Module {\n  val io = IO(new Bundle {\n    val cond = Input(Bool())\n    val a = Input(UInt(28.W))\n    val out = Output(UInt(28.W))\n  })\n  \n  io.out := 0.U\n  \n  when (io.cond) {\n    io.out := io.a\n  } .otherwise {\n    io.out := 0.U\n  }\n}"}
{"instruction": "Define a 11-bit UInt Wire named 'v_554'.", "input": "", "output": "\nimport chisel3._\n\nclass GlobalWire_27 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(11.W))\n  })\n  // Task: Define a UInt Wire named 'v_554'\n  val v_554 = Wire(UInt(11.W))\n  \n  \n  v_554 := 0.U.asTypeOf(v_554)\n  \n\n  io.out := v_554\n}"}
{"instruction": "Use 'when' to assign output based on a condition.", "input": "", "output": "\nimport chisel3._\n\nclass BranchFlow_28 extends Module {\n  val io = IO(new Bundle {\n    val cond = Input(Bool())\n    val a = Input(UInt(31.W))\n    val out = Output(UInt(31.W))\n  })\n  \n  io.out := 0.U\n  \n  when (io.cond) {\n    io.out := io.a\n  } .otherwise {\n    io.out := 0.U\n  }\n}"}
{"instruction": "Implement a 2-stage shift register.", "input": "", "output": "\nimport chisel3._\n\nclass SyncDelayLine_30 extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  \n  val r1 = RegNext(io.in)\n  val r2 = RegNext(r1)\n  \n  io.out := r2\n}"}
{"instruction": "Define a Wire Vec of 7 UInts, each 26-bit wide.", "input": "", "output": "\nimport chisel3._\n\nclass GlobalBuffer_29 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(Vec(7, UInt(26.W)))\n  })\n  // Task: Define a Vec of 7 UInts\n  val vec_666 = Wire(Vec(7, UInt(26.W)))\n  \n  for (i <- 0 until 7) {\n    vec_666(i) := 0.U.asTypeOf(UInt(26.W))\n  }\n\n  io.out := vec_666\n}"}
{"instruction": "Define a Wire Vec of 5 UInts, each 27-bit wide.", "input": "", "output": "\nimport chisel3._\n\nclass GlobalBuffer_31 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(Vec(5, UInt(27.W)))\n  })\n  // Task: Define a Vec of 5 UInts\n  val vec_590 = Wire(Vec(5, UInt(27.W)))\n  \n  for (i <- 0 until 5) {\n    vec_590(i) := 0.U.asTypeOf(UInt(27.W))\n  }\n\n  io.out := vec_590\n}"}
{"instruction": "Define a Wire Vec of 2 UInts, each 7-bit wide.", "input": "", "output": "\nimport chisel3._\n\nclass SimpleBus_32 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(Vec(2, UInt(7.W)))\n  })\n  // Task: Define a Vec of 2 UInts\n  val vec_683 = Wire(Vec(2, UInt(7.W)))\n  \n  for (i <- 0 until 2) {\n    vec_683(i) := 0.U.asTypeOf(UInt(7.W))\n  }\n\n  io.out := vec_683\n}"}
{"instruction": "Use 'when' to assign output based on a condition.", "input": "", "output": "\nimport chisel3._\n\nclass BranchFlow_33 extends Module {\n  val io = IO(new Bundle {\n    val cond = Input(Bool())\n    val a = Input(UInt(5.W))\n    val out = Output(UInt(5.W))\n  })\n  \n  io.out := 0.U\n  \n  when (io.cond) {\n    io.out := io.a\n  } .otherwise {\n    io.out := 0.U\n  }\n}"}
{"instruction": "Use 'when' to assign output based on a condition.", "input": "", "output": "\nimport chisel3._\n\nclass CondFlow_34 extends Module {\n  val io = IO(new Bundle {\n    val cond = Input(Bool())\n    val a = Input(UInt(18.W))\n    val out = Output(UInt(18.W))\n  })\n  \n  io.out := 0.U\n  \n  when (io.cond) {\n    io.out := io.a\n  } .otherwise {\n    io.out := 0.U\n  }\n}"}
{"instruction": "Implement a 2-to-1 Multiplexer for 9-bit signals.", "input": "", "output": "\nimport chisel3._\n\nclass PathChooser_35 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(Bool())\n    val a = Input(UInt(9.W))\n    val b = Input(UInt(9.W))\n    val out = Output(UInt(9.W))\n  })\n  \n  // Logic: 2-to-1 Mux\n  io.out := Mux(io.sel, io.a, io.b)\n}"}
{"instruction": "Define a 13-bit UInt Wire named 'v_815'.", "input": "", "output": "\nimport chisel3._\n\nclass LocalUIntWire_36 extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(13.W))\n  })\n  // Task: Define a UInt Wire named 'v_815'\n  val v_815 = Wire(UInt(13.W))\n  \n  \n  v_815 := 0.U.asTypeOf(v_815)\n  \n\n  io.out := v_815\n}"}
{"instruction": "Implement a module performing bitwise AND on two 12-bit inputs.", "input": "", "output": "\nimport chisel3._\n\nclass FastAndGate_37 extends Module {\n  val io = IO(new Bundle {\n    val a = Input(UInt(12.W))\n    val b = Input(UInt(12.W))\n    val out = Output(UInt(12.W))\n  })\n  \n  // Logic: bitwise AND\n  io.out := io.a & io.b\n}"}
